---
title: "Arrays"
subtitle: "Our first data structure"
---

This note has the following goals:

* Understand what is an array.
* Call built-in functions and NumPy functions on arrays.
* Access individual elements of an array with indexing

We will first learn arrays through analyzing data; then, we will drill into array internals and the nitty-gritty of Python modules and methods. Finally, we will summarize array operations.

## Definitions

Let us discuss our first data structure in this course: **arrays**. An **array** is a sequential collection of values of a given data type:

* sequential: arranged like a line/queue
* collection: multiple values organized together. 

In arrays, each value is called an array **element**.

We have previously discussed the idea of tables: a rectangular data structure with rows and columns. We will see today that **arrays are a concise way to manipulate table columns**, because arrays facilitate common data processing that we may want to perform on columns.

::: {.callout-note title="Read _Inferential Thinking_"}
 Read [Ch 5.1](https://inferentialthinking.com/chapters/05/1/Arrays.html), which describes in detail how arrays can be used in arithmetic expressions to compute over their contents.
 
 Before continuing, make sure that:
 
 * You understand the figure that shows how to convert an array of Celsius temperatures to an array of Farenheit temperatures.
 
:::

### Today's dataset

The following table is drawn from the American Community Survey (ACS) of 2020. It shows education levels of adults 25 years or higher by state.
  
| State | Estimated total state population |Estimated high school graduate or higher (%) | Estimated bachelor's degree or higher (%) |
| --- | --- | --- | --- |
| Alabama | 3,344,006 | 86.9 | 26.2 |
| California | 26,665,143 | 83.9 | 34.7 |
| Florida | 15,255,326 | 88.5 | 30.5 |
| New York | 13,649,157 | 87.2 | 37.5 |
| Texas  | 18,449,851 | 84.4 | 30.7 |

## Creating arrays

Each of these table columns can be represented by an array.

Below, we create a new array for the column "Estimated high school graduate or higher (%)" and assign the returned array to a single name, `hs_or_higher`. This simple assignment statement is abstraction at work! Also note that the import statement gives us access to array functions with the `datascience` module, including `make_array`, which returns a new array with the provided argument values. 

```{python}
from datascience import *

hs_or_higher = make_array(86.9, 83.9, 88.5, 87.2, 84.4)
hs_or_higher
```

Let's make a few more arrays.

The array data type (as shown below) is a bit esoteric for now; we will discuss what NumPy (`np`) is very soon.

```{python}
bs_or_higher = make_array(26.2, 34.7, 30.5, 37.5, 30.7)
type(bs_or_higher)
```

When creating the state names array of strings below, what do you observe about the datatype, `dtype`? Hint: Count the number of characters in each string.

```{python}
states = make_array("Alabama", "California", "Florida", "New York", "Texas")
states
```

When creating the state population array below, why might we decide to make an integer array, as opposed to a string array?
```{python}
state_pop = make_array(3344006, 26665143, 15255326, 13649157, 18449851)
state_pop
```

::: {.callout-note title="More array details" collapse="true"}
The order of an array is fixed (i.e., they will be arranged in the order specified when building the array), and values can be repeated.

Array with 4 `int`s:

```{python}
make_array(5, -1, 0.3, 5)
```

Values in an array must all be of the same data type, and the `make_array` function will cast appropriately. Below, all values can be represented by strings:

```{python}
make_array(4, -4.5, "not a number")
```

Incidentally, we can clean up our code stylistically by makine line breaks after each argument:

```{python}
make_array("hello",
           "world",
           "!")
```
:::

## Element-wise arithmetic

Arrays allow us to write code that performs **the same operation on many pieces of data at once**. We can therefore easily use arithmetic operations on elements of numeric arrays where it "makes sense" (see sidenote).

To compute the estimated percentage by state of adults 25 years or higher that have not graduated high school, we can create a new array by performing arithmetic with an **array and a numeric value**:

```{python}
100 - hs_or_higher
```

To compute the estimated number by state of adults 25 years or higher with bachelor's degrees, we can create a new array by performing arithmetic with **two arrays**:

```{python}
bs_or_higher / 100 * state_pop
```

Sidenote: What do I mean by "makes sense"? Linear Algebra is a broad mathematical field that forms the foundations of much of data science and tabular data analysis. This element-wise array functionality is derived from the mathematical definitions of vectors and scalars. Take a linear algebra class if you want to learn more!

## Indexing

When people stand in a line, each person has a position. Similarly, each **element** (i.e., value) of an array has a position – called its **index**. Python, like many programming languages, is **zero-indexed**. This means that in an array, the first element has index 0, not 1.

In the `int_arr` array below, the first element (`3`) has index 0; the last element (`2`) has index 4.
```{python}
int_arr = make_array(3, -4, 0, 5, 2)
int_arr
```

### The Array Method `item()`

An array **method** is just like a function, but it must operate on an array using **"dot" syntax**. So the call looks like:

```
name_of_array.method(arguments)
```

We will discuss many more methods once we introduce tables, but for now let's learn our first method to index arrays.

We can access an element in an array by using its index and the `item()` method:

```{python}
int_arr.item(0)
```


```{python}
int_arr.item(3)
```

Because of zero-indexing, the largest valid index is 4 for the five-element `int_arr` array:
```{python}
#| error: true
int_arr.item(5)
```

In Python, we can also “count backwards” using **negative indexes**. -1 corresponds to the last element in a array; -2 corresponds to the second last element in a array; and so on.

```{python}
# functionally equivalent to int_arr.item(4)
int_arr.item(-1)
```


## Array Functions

As data scientists we may find it useful to perform operations on arrays beyond simple element-wise arithmetic operations. We can do so via a range of functions from different sources.

Here are some starter arrays to get us going. What are the resulting arrays created?

```{python}
int_arr = make_array(3, -4, 0, 5, 2)
str_arr = make_array("cm", "m", "in", "ft", "yd")
empty_arr = make_array() # challenge
```

::: {.callout-note title="Arrays created" collapse="true"}
```{python}
int_arr
```

```{python}
str_arr
```


An **empty** array is one with no elements:
```{python}
empty_arr
```
:::


We will describe the syntax and terminology of built-in and NumPy functions below, then provide a table of operations. Here's how we suggest working through this section:

1. Don't memorize these functions!
1. Instead, remember there are two types of functions for arrays: built-in functions and NumPy functions.
1. Get familiar with two tables, copied below. Get familiar with reading this tabl documentation to understand how each function works.
1. When writing your programs, look through these functions and see which function(s) can compose your solution.

### Built-in functions

Some **built-in functions** (i.e., included with Python) can take in arrays as arguments.

Here is a table of example built-in functions for arrays. Again, don't memorize the functions. Rather, get familiar with reading and predicting their outputs.

| Expression and Return value | Example(s) |
| - | - |  
| `len(arr)` Length of an array, providing the number of elements it contains. Useful for determining the size of an array dynamically. | `len(str_arr)   # 5` <br/> `len(empty_arr) # 0` | 
| `max(arr)` The largest value within an array. | `max(int_arr)    # 5` <br/> `max(str_arr)   # 'yd'` |
| `min(arr)` The smallest value within an array. | `min(int_arr) ` | 
| `sum(arr)` Sum of all values in an array. | `sum(int_arr)   # 6` <br/> `sum(str_arr)   # TypeError` |

: Built-in Python functions that take in array arguments.


::: {.callout-note title="Note 1: Argument data types" collapse="true"}
Remember that even though function names can be identical, call expressions can evaluate differently depending on the argument data type.
 `len(arg)`, for example, returns an integer value indicating the "length" of the argument `arg`. If `arg` is a string, it returns the number of characters; if `arg` is an array, it returns the number of elements.

```{python}
len(str_arr)
```

```{python}
len(str_arr.item(0)) # what is the argument here?
```
:::

::: {.callout-note title="Note 2: Expressions with string arrays" collapse="true"}
As you may have noticed above, calling these functions on strings return some seemingly bizarre values. After all, what does it mean to get the maximum value of an array of strings?

Instead of erroring out, the Pythonic convention is to consider alphabetic sorting as a way of ordering elements---hence, `"yd"` comes alphabetically after `"cm"` and `"ft"`, and so on.

We will not cover string comparisons in detail in this course. If you are curious about these algorithms, we encourage you to take a Data Structures course!
:::


Let's use these built-in functions to compute the _average_ (_mean_) value of the below array. We will discuss measures of average much later in this course.

```{python}
arr = make_array(30, -40, -4.5, 0, 35)
avg = sum(arr)/len(arr)
avg
```

Due to approximations in how the computer stores and operates on floats, the above number is as close to 4.1 (the true numeric average) as we can get with our Python calculator. Take a computer systems or computer architecture course for more information!

### NumPy functions

NumPy (pronounced "NUM-pie”) is a Python library with convenient and
powerful modules and functions for manipulating arrays. Any time we want to use NumPy, we must write an import statement:

```{python}
import numpy as np

arr = make_array(30, -40, -4.5, 0, 35)
arr
```

After putting this statement at the top of our notebook, we can then prepend `np.` to call a NumPy function. The below NumPy function call computes averages much more conveniently than our clever (but verbose) expression with built-in function calls, though it still suffers from floating point approximations:

```{python}
np.average(arr)
```

### NumPy Array Function Table

There are many, many types of NumPy array functions; the below table only scratches the surface of what is possible. Again, instead of memorizing functions, we encourage you to learn how to read documentation by considering the following:

1. What is the function name? How is this name informed by the function description?
1. What is the return value of this function?
    * If the data type of the return value is an array, is it the same length as the original array? Is the function therefore operating element-wise on the original array?
    * If the data type of the return value is a single value, how is this value computed from the different elements of the original array? 
1. Is the function changing the contents of the original array?

The answer to question 3 is **no** for all array functions we will cover in this course. **All array functions return a new array**.

| NumPy function | Description |
| - | --- | 
| `np.average(arr)` <br/> `np.mean(arr)` | The average (i.e., mean) value of `arr` |
| `np.sum(arr)` | The sum of all elements in `arr` |
| `np.prod(arr)` | The product of all elements in `arr` | 
| `np.count_nonzero(arr)` | The number of elements in arr that are not equal to 0 |
| `np.diff(arr)` | The difference between each element and the previous one value of `arr`. Returns an array of length 1 _less_ than the original. |
| `np.cumsum(arr)` | The cumulative sum of all elements in `arr`. |
| `np.sqrt(arr)` | The square roots of each element in `arr`.|
| `np.log(arr)` | The natural logarithm of each element in `arr`. |
| `np.log10(arr)` | The base-10 logarithm of each element in `arr`. |
: A subset of NumPy array functions. A full reference is in the Data 6 reference sheet.

Refer to the lecture notebook for example call expressions involving these NumPy functions. Refer to the **Data 6 reference sheet** for all functions we will expect you to be familiar with (not memorize!) in this course.


## External Reading

* (mentioned in notes) _Computational and Inferential Thinking_, [Ch 5.1](https://inferentialthinking.com/chapters/05/1/Arrays.html)
* (optional) Tomas Beuzen. _Python Programming for Data Science_ [Ch 1.2](https://www.tomasbeuzen.com/python-programming-for-data-science/chapters/chapter1-basics.html#basic-python-data-types).

## References

U.S. Census Bureau, "EDUCATIONAL ATTAINMENT," American Community Survey 5-Year Estimates Subject Tables, Table S1501, 2020, <https://data.census.gov/table/ACSST5Y2020.S1501?q=2020+education&t=Age+and+Sex:Educational+Attainment&g=010XX00US$0400000>, accessed on August 24, 2025.