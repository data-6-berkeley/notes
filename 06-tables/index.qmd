---
title: "Table Fundamentals"
subtitle: ""
---

::: {.callout-note title="Read _Inferential Thinking_"}
 Read [Ch 6 intro](https://inferentialthinking.com/chapters/06/Tables.html), which describes the `Table` object type from the `datascience` library. 

 This is a very dense chapter, as it has lots of Python syntax. We will review it in detail. Before moving on, we encourage you to focus on the following questions:

 1. What is the _syntax_ of the `with_columns` method? How does this method make a table?
 1. What are some table methods?
 1. What Python expression gets you the number of rows? a specific column? (bonus) How does the syntax differ between these two cases?
:::

If you are new to programming, it is easy to get lost in the syntax of Python! For today, we will therefore focus on a few high-level goals:

* How to translate your **existing critical thinking skills** and propensity for exploratory data analysis into algorithmic thinking with **`datascience` Tables**
* How to read **Python documentation** to find what you want
* How to **debug code systematically**

In other words, you will **not be expected to memorize all aspects of Table**s (it's as if we have a theme in this class...)! But you will have natural impulses for understanding and working with tabular data, many of which directly map to specific Table methods and attributes. To write Python code, then, you will need to learn to work with documentation to do this translation, and—when the precise methods don't exist—construct new algorithms to achieve what you want. The more familiar you are with the documentation---and consequently, what is possible with `Table`s---the more you can focus on algorithmic thinking.


::: {.callout-tip title="Documentation, documentation, documentation"}

This entire note revolves around getting used to using the documentation on the [Data 6 Python Reference](../reference.html) page. Keep that page open as you read this one!

:::

## Definitions
To begin, recall the terminology we have been using to describe tables so far:

* **Table**: Retangular data structure.
  * **Columns** (vertical) correspond to **variables** (AKA features, or attributes) that measure and operationalize social concepts.
  * **Rows** (horizontal) correspond to **records** (AKA entries), which are specific values of variables for a given individual, group, etc.---whatever your unit of analysis is. 

We work with the `datascience` package's `Table`.
```{python}
from datascience import *
import numpy as np
```

## Today's Dataset: Schools

This lecture we will return to the dataset of public four-year colleges and universities in California ([Wikipedia](https://en.wikipedia.org/wiki/List_of_colleges_and_universities_in_California)).

To work with this table, we first load it in from a file called `data/cal_unis.csv`.

```{python}
schools = Table.read_table('data/cal_unis.csv')
```

Let's break down what we meant by "load it in":
* The right-hand-side of the assignment calls a function that returns a `datascience` `Table` **object** from the provided data file. 
* The left-hand-side of the assignment assigns this object to the Python name `schools`.
* After this assignment statement, then we can use `schools` as the particular Table object that has the tabular data we want.

Running the below cell evaluates `schools` and displays that tabular data to us:

```{python}
schools
```

Let's get to exploring and understanding our tabular data!

## Exercise 1: Find Table Dimensions

First off: How many rows and columns are in our `schools` table?
```{python}
print(schools.num_rows)
print(schools.num_columns)
```

What variables are being recorded?

```{python}
print(schools.labels)
```

We didn't conjure these expressions out of nowhere. Instead, we:

1. Looked at the [Data 6 Python Reference](../reference.html) page
1. Scrolled down to the "Tables and Table Methods" section
1. Skimmed the reference until we found documentation that seemed close to what we want
1. Translated the name `tbl` into `schools`.
1. Tried it out

Bonus: You'll notice the "dot" syntax for accessing these values, also known as table attributes. See the Bonus last section for a more detailed explanation of this programming terminology.

## Column-First Paradigm

Because columns represent variables, we will take a **column-first approach** to tables.

To extract, delete, or make columns from a table named `tbl`:

* `tbl.select(...)` returns a new table with a subset of columns.
* `tbl.drop(...)` and returns a new table without a subset of columns
* `tbl.with_columns(...)` returns a new table with additional new column(s).

```{python}
schools.select('Name', 'Enrollment')
```

```{python}
schools.drop('Founded', 'County')
```

**Note**: The above two cells were run in sequence. Each table method returns a new table, so our original table `schools` is unchanged.


### Modifying Tables

::: {.callout-tip title="Table methods return copies"}
All table methods return **copies of information** from the original table! This paradigm is quite useful for data analysis. From _Inferential Thinking_: 

> [Table methods] create new smaller tables that share the same data. The fact that the original table is preserved is useful! You can generate multiple different tables that only consider certain columns without worrying that one analysis will affect the other.

:::


If we would like to modify the original table, then we must re-assign `schools` to the new return value:

```{python}
schools = schools.with_columns(
    "Years since founding",
    2025 - schools.column("Founded")
)
schools
```

## Filtering Rows

Often we would like to perform row  **filtering**, where we only extract row entries that match a specific **feature**.

By **exact match**: `tbl.where(column, value)`. Create a new table of only the rows where column `column` matches the value `value`. 

```{python}
schools.where("Institution", "UC")
```

By **index**: `tbl.take(row_indices)`. Create a new table of only the rows with an index specified in `row_indices`.

```{python}
schools.take(1, 3, 5)
```

Are rows zero-indexed or one-indexed? Why?

## Creating New Tables

So far we've used a table with pre-existing data. We can also make **new Tables** with a special function: `Table()`.

```{python}
Table()
```

Check it out!!!
```{python}
states = Table().with_columns('State', np.array(['California', 'New York', 'Florida', 'Texas', 'Pennsylvania']),'Code', np.array(['CA', 'NY', 'FL', 'TX', 'PA']), 'Population (millions)', np.array([39.3, 19.3, 21.7, 29.3, 12.8]))
states
```

...unfortunately, due to poor coding style, the above code is quite unreadable. Let's use whitespace (new lines and indents) to delineate what we are doing:

```{python}
states = Table().with_columns(
  'State', np.array(['California', 'New York', 'Florida', 'Texas', 'Pennsylvania']),
  'Code', np.array(['CA', 'NY', 'FL', 'TX', 'PA']),
  'Population (millions)', np.array([39.3, 19.3, 21.7, 29.3, 12.8])
)
states
```

### Method Chaining

**Method chaining** in Python is when the object returned from one method becomes the object to use in the next method. In this case:

1. Calling the `Table` returns an empty table.
1. The method `with_columns` is called on the empty table object, returning a table with the columns State, Code, and Population.
1. This return value is then assigned to `states`.

::: {.callout-tip title="Whitespace formatting"}
Note the closed parenthesis on the final line. This helps "match" parentheses together.
:::

## Bonus: Methods vs. Attributes

Return to the third focus question from the _Inferential Thinking_ reading.

> What Python expression gets you the number of rows? a specific column? (bonus) How does the syntax differ between these two cases?

The textbook wording "overloads" two different Python syntax constructs. From the Python glossary:


::: {.callout-note title="Attribute"}

[**Attribute**](https://docs.python.org/3/glossary.html#term-attribute): A value associated with an object which is usually referenced by name using dotted expressions. For example, if an object _o_ has an attribute _a_ it would be referenced as _o.a_. 

In other words, attributes are named values tied to specific objects. To get these values, we must refer to them by their name using "dot" syntax.

:::

```{python}
schools.num_rows
```


::: {.callout-note title="Method"}

[**Method**](https://docs.python.org/3/glossary.html#term-method) A function which is defined inside a class body.

The Python glossary definition above is a more opaque definition than we would like. But you can think of the methods we study in this class as functions that take into account the attributes and values of specific objects. In order to call them on a specific operation, we also use "dot" syntax. Because they are functions, we must use call expression syntax with parenthesis, and provide arguments as needed.

:::

```{python}
schools.column("Enrollment")
```

**Which to syntax use**? To determine which "dot" syntax to use, read the documentation. The entire `Table` class has been defined for us already, and the designers of the `datascience` package have predetermined which table features make sense to have as attributes, and which  features make sense to return as values from a method call. But as a rule of thumb, if you need to specify any additional detail to get what you want, you will likely need to call a function: use table methods and pass in arguments. See the `column` method call above.

Another key indicator is what happens when you use incorrect syntax:

```{python}
#| error: true
schools.num_rows()
```

The above error message means that Python assumed you wanted to call a function `num_rows` (specifically, a method of the Table `schools`); however, when run, `num_rows` was actually an `int` data type attribute, and `int`s are not callable. Similarly, below:

```{python}
schools.column
```

The above statement did not error, but it did not output a column, either. Rather, it output a `method` of a table, but it didn't call this method.